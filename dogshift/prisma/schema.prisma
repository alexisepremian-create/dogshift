// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  OWNER
  SITTER
}

enum BookingStatus {
  DRAFT
  PENDING_PAYMENT
  PENDING_ACCEPTANCE
  PAID
  CONFIRMED
  PAYMENT_FAILED
  CANCELLED
  REFUNDED
  REFUND_FAILED
}

enum NotificationType {
  newMessages
  newBookingRequest
  paymentReceived
  bookingConfirmed
  bookingReminder
}

enum InviteCodeType {
  single_use
  master
}

enum VerificationStatus {
  not_verified
  pending
  approved
  rejected
}

enum ServiceType {
  PROMENADE
  DOGSITTING
  PENSION
}

enum AvailabilityStatus {
  AVAILABLE
  ON_REQUEST
  UNAVAILABLE
}

model User {
  id              String    @id @default(cuid())
  clerkUserId     String?   @unique
  email           String    @unique
  name            String?
  image           String?
  emailVerified   DateTime?
  passwordHash    String?
  hostProfileJson String?
  role            Role      @default(OWNER)
  sitterId        String?   @unique
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  accounts Account[]
  sessions Session[]

  bookings       Booking[] @relation("UserBookings")
  sitterBookings Booking[] @relation("SitterBookings")

  ownerConversations  Conversation[] @relation("OwnerConversations")
  sitterConversations Conversation[] @relation("SitterConversations")
  sentMessages        Message[]

  sitterProfile SitterProfile?

  sitterApplications SitterApplication[]

  notifications Notification[]

  reviewsWritten  Review[] @relation("ReviewOwner")
  reviewsReceived Review[] @relation("ReviewSitter")

  availabilities Availability[] @relation("SitterAvailabilities")

  availabilityRules      AvailabilityRule[]
  availabilityExceptions AvailabilityException[]
  serviceConfigs         ServiceConfig[]
}

model Notification {
  id String @id @default(cuid())

  userId String
  type   NotificationType

  title    String
  body     String?
  entityId String?
  url      String?
  metadata Json?

  idempotencyKey String

  createdAt DateTime  @default(now())
  readAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, idempotencyKey])
  @@index([userId, readAt])
  @@index([userId, createdAt])
}

model InviteCode {
  id String @id @default(cuid())

  code      String         @unique
  type      InviteCodeType
  usedAt    DateTime?
  expiresAt DateTime?
  note      String?

  createdAt DateTime @default(now())
}

model SitterApplication {
  id String @id @default(cuid())

  userId String
  data   Json

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

model SitterProfile {
  id String @id @default(cuid())

  userId   String @unique
  sitterId String @unique

  published   Boolean   @default(false)
  publishedAt DateTime?

  displayName String?
  city        String?
  postalCode  String?
  bio         String?
  avatarUrl   String?

  lat Float?
  lng Float?

  services Json?
  pricing  Json?
  dogSizes Json?

  termsAcceptedAt   DateTime?
  termsVersion      String?
  profileCompletion Int       @default(0)

  verificationStatus      VerificationStatus @default(not_verified)
  idDocumentUrl           String?
  selfieUrl               String?
  verificationSubmittedAt DateTime?
  verificationReviewedAt  DateTime?
  verificationNotes       String?

  verificationAccessLogs VerificationAccessLog[]

  stripeAccountId               String?
  stripeAccountStatus           String?
  stripeOnboardingCompletedAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([published])
  @@index([city])
  @@index([postalCode])
  @@index([verificationStatus])
}

model VerificationAccessLog {
  id String @id @default(cuid())

  sitterProfileId String
  sitterId        String

  action  String
  fileKey String?

  adminClerkUserId String?
  userAgent        String?

  createdAt DateTime @default(now())

  sitterProfile SitterProfile @relation(fields: [sitterProfileId], references: [id], onDelete: Cascade)

  @@index([sitterProfileId, createdAt])
  @@index([sitterId, createdAt])
}

model Booking {
  id String @id @default(cuid())

  userId   String
  sitterId String

  service   String?
  startDate DateTime?
  endDate   DateTime?

  serviceType ServiceType?
  startAt     DateTime?
  endAt       DateTime?

  message String?

  status            BookingStatus @default(PENDING_PAYMENT)
  canceledAt        DateTime?
  amount            Int
  currency          String        @default("chf")
  platformFeeAmount Int

  stripeSessionId       String?
  stripePaymentIntentId String?

  stripeTransferId            String?
  stripeApplicationFeeAmount  Int           @default(0)

  stripeRefundId String?
  refundedAt     DateTime?

  reviewRequestEmailSentAt DateTime?

  archivedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User @relation("UserBookings", fields: [userId], references: [id], onDelete: Cascade)
  sitter User @relation("SitterBookings", fields: [sitterId], references: [sitterId], onDelete: Restrict)

  conversations Conversation[] @relation("BookingConversations")

  review Review?

  @@index([userId])
  @@index([sitterId])
  @@index([stripeSessionId])
  @@index([stripePaymentIntentId])
}

model Review {
  id String @id @default(cuid())

  bookingId String @unique
  ownerId   String
  sitterId  String

  rating  Int
  comment String?
  anonymous Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  owner   User    @relation("ReviewOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  sitter  User    @relation("ReviewSitter", fields: [sitterId], references: [sitterId], onDelete: Restrict)

  @@index([sitterId, createdAt])
  @@index([ownerId, createdAt])
}

model Availability {
  id String @id @default(cuid())

  sitterId String
  dateKey String
  isAvailable Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sitter User @relation("SitterAvailabilities", fields: [sitterId], references: [sitterId], onDelete: Cascade)

  @@unique([sitterId, dateKey])
  @@index([sitterId, dateKey])
}

model AvailabilityRule {
  id String @id @default(cuid())

  sitterId   String
  dayOfWeek  Int
  startMin   Int
  endMin     Int
  status     AvailabilityStatus

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sitter User @relation(fields: [sitterId], references: [sitterId], onDelete: Cascade)

  @@index([sitterId, dayOfWeek])
  @@index([sitterId])
}

model AvailabilityException {
  id String @id @default(cuid())

  sitterId  String
  date      DateTime @db.Date
  startMin  Int
  endMin    Int
  status    AvailabilityStatus

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sitter User @relation(fields: [sitterId], references: [sitterId], onDelete: Cascade)

  @@index([sitterId, date])
  @@index([sitterId])
}

model ServiceConfig {
  id String @id @default(cuid())

  sitterId     String
  serviceType  ServiceType
  enabled      Boolean @default(true)

  slotStepMin      Int
  minDurationMin   Int
  maxDurationMin   Int
  leadTimeMin      Int
  bufferBeforeMin  Int
  bufferAfterMin   Int

  overnightRequired Boolean @default(false)
  checkInStartMin   Int?
  checkInEndMin     Int?
  checkOutStartMin  Int?
  checkOutEndMin    Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sitter User @relation(fields: [sitterId], references: [sitterId], onDelete: Cascade)

  @@unique([sitterId, serviceType])
  @@index([sitterId])
  @@index([serviceType])
}

model Conversation {
  id String @id @default(cuid())

  ownerId   String
  sitterId  String
  bookingId String?

  lastMessageAt      DateTime?
  lastMessagePreview String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  owner   User     @relation("OwnerConversations", fields: [ownerId], references: [id], onDelete: Cascade)
  sitter  User     @relation("SitterConversations", fields: [sitterId], references: [sitterId], onDelete: Restrict)
  booking Booking? @relation("BookingConversations", fields: [bookingId], references: [id], onDelete: SetNull)

  messages Message[]

  @@unique([ownerId, sitterId])
  @@index([ownerId])
  @@index([sitterId])
  @@index([bookingId])
  @@index([lastMessageAt])
}

model Message {
  id String @id @default(cuid())

  conversationId String
  senderId       String
  body           String
  readAt         DateTime?

  createdAt DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
